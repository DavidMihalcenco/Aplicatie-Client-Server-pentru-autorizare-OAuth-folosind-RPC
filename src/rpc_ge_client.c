/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "rpc_ge.h"

char **Commands; // Comenzile citite in fisier
int nrCommands; // Numarul comenzilor in fisier
int currentclient; // Indexul la care o sa adaug un clien nou
int nrClientsDB; // Numarul curent de clienti in database

// Structura unui clien
typedef struct clientStr{
	char *clientid; // id client care vine din fisier
	char *clauth; // tokenul de autentificare
	char *clrefr; // tokenul de refresh
	char *claccs; // tokenul de acces
}clientStruct;

clientStruct* clientDataBase; // baza de date cu clienti 
void
oauthauthorization_1(char *host)
{
	CLIENT *clnt;
	char * *result_1;
	char * request_authorization_1_arg;
	AccessResponse  *result_2;
	AccessRequest  request_token_1_arg;
	DelegatedActionResponse  *result_3;
	DelegatedActionRequest  validate_action_1_arg;
	char * *result_4;
	char * approve_token_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, OauthAuthorization, OauthVersion, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */
	for(int i = 0; i <nrCommands; ++i){
		// Alocare pentru ceea ce citesc din fiecare linie, inclusiv linia
		char *line = calloc(LINE_SIZE, sizeof(char));
		char *client = calloc(SUBLINE_SIZE, sizeof(char));
		char *comm = calloc(SUBLINE_SIZE, sizeof(char));
		char *app = calloc(SUBLINE_SIZE, sizeof(char));
		int exist = 0;

		line = Commands[i];

		// Extragere informatie din linie
		client = strtok(line,",");
		comm = strtok(NULL,",");
		app = strtok(NULL,",");

		if(strcmp(comm,"REQUEST") == 0){
			
			for(int i = 0 ; i < nrClientsDB; ++i){
				if(strcmp(clientDataBase[i].clientid,client)==0){
					exist = 1;
				}
			}

			if(exist == 0){
				clientDataBase[nrClientsDB].clientid = strdup(client);
				nrClientsDB++;
			}

			request_authorization_1_arg = calloc(TOKENS_SIZE, sizeof(char));
			strcpy(request_authorization_1_arg,client);
			result_1 = request_authorization_1(&request_authorization_1_arg, clnt);
			if (result_1 == (char **) NULL) {
				clnt_perror (clnt, "call failed");
			}
			if(strcmp(*result_1,"Match not found\n") == 0){
				printf("USER_NOT_FOUND\n");
				continue;
			}

			approve_token_1_arg = calloc(TOKENS_SIZE , sizeof(char));
			result_4 = approve_token_1(result_1, clnt);
			if (result_4 == (char **) NULL) {
				clnt_perror (clnt, "call failed");
			}
			if(strcmp(*result_4,*result_1)==0){
				printf("REQUEST_DENIED\n");
				continue;
			}
			
			request_token_1_arg.user_id = strdup(client);
			request_token_1_arg.authorization_token  = *result_4;
			request_token_1_arg.refresh = atoi(app);
			request_token_1_arg.valabil = 0;
			result_2 = request_token_1(&request_token_1_arg, clnt);
			if (result_2 == (AccessResponse *) NULL) {
				clnt_perror (clnt, "call failed");
			}
			if(strcmp(result_2->response_type,"REQUEST DENIED")==0){
				printf("REQUEST_DENIED\n");
				continue;
			}
			for(int i = 0 ; i < nrClientsDB; ++i){
				if(strcmp(clientDataBase[i].clientid,client)==0){
					clientDataBase[i].claccs = strdup(result_2->access_token);
					clientDataBase[i].clrefr = strdup(result_2->refresh_token);
					continue;
				}
			}

			if(atoi(app)==1){
				printf("%s -> %s,%s\n",*result_1,result_2->access_token,result_2->refresh_token);
			}else{
				printf("%s -> %s\n",*result_1,result_2->access_token);
			}
		}else{
			char *acct = calloc(ERROR_SIZE, sizeof(char));
			strcpy(acct,"NOTDB");
			for(int i = 0 ; i < nrClientsDB; ++i){
				if(strcmp(clientDataBase[i].clientid,client)==0){
					strcpy(acct,clientDataBase[i].claccs);
					break;
				}
			}
			validate_action_1_arg.access_token = acct;
			validate_action_1_arg.action = comm;
			validate_action_1_arg.autoRefresh = 0;
			validate_action_1_arg.resource = app;
			result_3 = validate_action_1(&validate_action_1_arg, clnt);
			if (result_3 == (DelegatedActionResponse *) NULL) {
				clnt_perror (clnt, "call failed");
			}
			if(strcmp(result_3->new_acc_token,"NULL") != 0){
				for(int i = 0 ; i < nrClientsDB; ++i){
					if(strcmp(clientDataBase[i].clientid,client) == 0){
						strcpy(clientDataBase[i].claccs,result_3->new_acc_token);
						strcpy(clientDataBase[i].clrefr,result_3->new_refr_token);
						break;
					}
				}
			}
			printf("%s\n",result_3->response);
		}
	}

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}

/*
	Functia de citire din fisieul client.in si stocarea lor in Commands
	filename - Calea la care se afla fisierul
*/
void storeCommandsFromFile(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        perror("Error opening file");
        exit(EXIT_FAILURE);
    }
    nrCommands = 0;

    char line[100];
    while (fgets(line, sizeof(line), file) != NULL) {
        line[strcspn(line, "\n")] = 0;

        char *temp = strdup(line);
        Commands = realloc(Commands, (nrCommands + 1) * sizeof(char *));
        Commands[nrCommands++] = temp;
    }

    fclose(file);
}


int
main (int argc, char *argv[])
{	
	char *filename = malloc(FILENAME_SIZE * sizeof(char));
	strcpy(filename, argv[2]);
	storeCommandsFromFile(filename);
	// Alocare memorie pentru data base
	clientDataBase = calloc(NR_CLIENTS_DATABASE, sizeof(clientStruct));
	for(int i = 0; i < NR_CLIENTS_DATABASE ; ++i){
		clientDataBase[i].clientid = calloc(TOKENS_SIZE, sizeof(char));
		clientDataBase[i].claccs = calloc(TOKENS_SIZE, sizeof(char));
		clientDataBase[i].clauth = calloc(TOKENS_SIZE, sizeof(char));
		clientDataBase[i].clrefr= calloc(TOKENS_SIZE, sizeof(char));
	}
	currentclient = 0;
	nrClientsDB = 0;
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	oauthauthorization_1 (host);
exit (0);
}
